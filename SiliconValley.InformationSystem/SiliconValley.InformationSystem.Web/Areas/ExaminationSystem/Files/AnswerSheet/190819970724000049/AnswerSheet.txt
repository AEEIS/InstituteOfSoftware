[{"questionid":"12","answer":"\n\n                .NET的3C：CTS、CLS和CLR.NET结合Java和COM解决方案两者优点来解决互操作性问题。类似于COM定义的标准二进制格式，.NET定义了一个称为通用类型系统Common Type System(CTS)的类型标准。这个类型系统不但实现了COM的变量兼容类型，而且还定义了通过用户自定义类型的方式来进行类型扩展。任何以.NET平台作为目标的语言必须建立它的数据类型与CTS的类型间的映射。所有.NET语言共享这一类型系统，实现它们之间无缝的互操作。该方案还提供了语言之间的继承性。例如，用户能够在VB.NET中派生一个由C#编写的类。很显然，编程语言的区别不仅仅在于类型。例如，一些语言支持多继承性，一些语言支持无符号数据类型，一些语言支持运算符重载。用户应认识到这一点，因此.NET通过定义公共语言规范(CLS：Common Language Specification)，限制了由这些不同引发的互操作性问题。CLS制定了一种以.NET平台为目标的语言所必须支持的最小特征，以及该语言与其他.NET语言之间实现互操作性所需要的完备特征。认识到这点很重要，这里讨论的特征问题已不仅仅是语言间的简单语法区别。例如，CLS并不去关心一种语言用什么关键字实现继承，只是关心该语言如何支持继承。CLS是CTS的一个子集。这就意味着一种语言特征可能符合CTS标准，但又超出CLS的范畴。例如：C#支持无符号数字类型，该特征能通过CTS的测试，但CLS却仅仅识别符号数字类型。因此，如果用户在一个组件中使用C#的无符号类型，就可能不能与不使用无符号类型的语言(如VB.NET)设计的.NET组件实现互操作。这里用的是“可能不”，而不是“不可能”，因为这一问题实际依赖于对non-CLS-compliant项的可见性。事实上，CLS规则只适用于或部分适用于那些与其他组件存在联系的组件中的类型。实际上，用户能够安全实现含私有组件的项目，而该组件使用了用户所选择使用的.NET语言的全部功能，且无需遵守CLS的规范。另一方面，如果用户需要.NET语言的互操作性，那么用户的组件中的公共项必须完全符合CLS规范。————————————————版权声明：本文为CSDN博主「zengjibing」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/zengjibing/article/details/3918008\n\n\n            ","questionScores":"7.5"},{"questionid":"5","answer":"\n\n                简述 private、 protected、 public、 internal 修饰符的访问权限。 private : 私有成员, 在该类的内部才可以访问。 protected : 保护成员，该类内部和继承类中可以访问。 public : 公共成员，完全公开，没有访问限制。 internal: 在同一命名空间内可以访问。\n\n\n            ","questionScores":"7.5"},{"questionid":"9","answer":"\n\n                request\n\n\n            ","questionScores":"4.5"},{"questionid":"6","answer":"\n\n                答题区\n\n\n            ","questionScores":"4.5"},{"questionid":"8","answer":"\n\n                Overload是重载的意思，Override是覆盖的意思，也就是重写。 重载Overload表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。\n\n\n            ","questionScores":"6"}]